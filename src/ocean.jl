"Returns empty ocean type for initialization purposes."
function createEmptyOcean()
    return Ocean(false,
                 zeros(1),
                 zeros(1),
                 zeros(1),
                 zeros(1),
                 zeros(1),
                 zeros(1),
                 zeros(1),
                 zeros(1,1,1,1),
                 zeros(1,1,1,1),
                 zeros(1,1,1,1),
                 zeros(1,1,1,1))
end

"""
Read NetCDF file generated by MOM6 (e.g. `prog__####_###.nc`) from disk and 
return as `Ocean` data structure.
"""
function readOceanNetCDF(filename::String)

    if !isfile(filename)
        error("$(filename) could not be opened")
    end
    u_staggered::Array{float, 4} = NetCDF.ncread(filename, "u")
    v_staggered::Array{float, 4} = NetCDF.ncread(filename, "v")
    u, v = convertToColocatedOceanGrid(u_staggered, v_staggered)

    ocean = Ocean(filename,
                  NetCDF.ncread(filename, "Time"),

                  NetCDF.ncread(filename, "xq"),
                  NetCDF.ncread(filename, "yq"),
                  NetCDF.ncread(filename, "xh"),
                  NetCDF.ncread(filename, "yh"),
                  NetCDF.ncread(filename, "zl"),
                  NetCDF.ncread(filename, "zi"),

                  u,
                  v,
                  NetCDF.ncread(filename, "h"),
                  NetCDF.ncread(filename, "e"))
    return ocean
end

"""
Convert gridded data from staggered (Arakawa-C) to collocated grid (Arakawa-A) 
through interpolation.  The new data points are located in the centers of the 
original staggered grid (spatial coordinates `xh` and `yh`).
"""
function convertToColocatedOceanGrid(u_in::Array{float, 4},
                                     v_in::Array{float, 4})
    u = Array{float}(size(u_in))
    v = Array{float}(size(v_in))
    nx = size(u_in)[1]
    ny = size(u_in)[2]
    for i=1:nx
        for j=1:ny
            if j < ny - 1
                u[i, j, :, :] = (u_in[i, j, :, :] + u_in[i, j+1, :, :])/2.
            else
                u[i, j, :, :] = u_in[i, j, :, :]
            end
            if i < nx - 1
                v[i, j, :, :] = (v_in[i, j, :, :] + v_in[i+1, j, :, :])/2.
            else
                v[i, j, :, :] = v_in[i, j, :, :]
            end
        end
    end
    return u, v
end

"""
Ocean data is containted in `Ocean` type at discrete times (`Ocean.time`).  This 
function performs linear interpolation between time steps to get the approximate 
ocean state at any point in time.  If the `Ocean` data set only contains a 
single time step, values from that time are returned.
"""
function interpolateOceanState(ocean::Ocean, t::float)
    if length(ocean.time) == 1
        return ocean.u, ocean.v, ocean.h, ocean.e
    elseif t < ocean.time[1] || t > ocean.time[end]
        error("selected time (t = $(t)) is outside the range of time steps in 
              the ocean data")
    end

    i = 1
    rel_time = 0.
    while i < length(ocean.time)
        if ocean.time[i+1] < t
            i += 1
            continue
        end

        dt = ocean.time[i+1] - ocean.time[i]
        rel_time = (t - ocean.time[i])/dt
        if rel_time < 0. || rel_time > 1.
            error("time bounds error")
        end
        break
    end

    return ocean.u[:,:,:,i]*(1. - rel_time + ocean.u[:,:,:,i+1]*rel_time),
        ocean.v[:,:,:,i]*(1. - rel_time) + ocean.v[:,:,:,i+1]*rel_time,
        ocean.h[:,:,:,i]*(1. - rel_time) + ocean.h[:,:,:,i+1]*rel_time,
        ocean.e[:,:,:,i]*(1. - rel_time) + ocean.e[:,:,:,i+1]*rel_time
end

"""
Add Stokes-type drag from velocity difference between ocean and ice floe.
"""
function addOceanDrag!(simulation::Simulation)
    if !simulation.ocean.id
        error("no ocean data read")
    end

    u, v, h, e = interpolateOceanState(simulation.ocean, simulation.time)

end
