<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · Granular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Granular.jl logo"/></a><h1>Granular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/installation.html">Installation</a></li><li><a class="toctext" href="../man/package_contents.html">Package contents</a></li><li><a class="toctext" href="../man/methods.html">Computational methods</a></li><li><a class="toctext" href="../man/getting_started.html">Getting started</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="public.html">Public API</a><ul class="internal"><li><a class="toctext" href="#main-index-1">Index</a></li><li><a class="toctext" href="#Public-Interface-1">Public Interface</a></li></ul></li><li><a class="toctext" href="internals.html">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="public.html">Public API</a></li></ul><a class="edit-page" href="https://github.com/anders-dc/Granular.jl/blob/master/docs/src/lib/public.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Public API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-API-documentation-1" href="#Public-API-documentation-1">Public API documentation</a></h1><p>Documentation for <code>Granular.jl</code>&#39;s public interface.</p><p>See <a href="internals.html#Package-internal-documentation-1">Package-internal documentation</a> for internal package docs.</p><h2><a class="nav-anchor" id="main-index-1" href="#main-index-1">Index</a></h2><ul><li><a href="public.html#Granular"><code>Granular</code></a></li><li><a href="public.html#Granular.addAtmosphereDrag!-Tuple{Granular.Simulation}"><code>Granular.addAtmosphereDrag!</code></a></li><li><a href="public.html#Granular.addBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.addBodyForce!</code></a></li><li><a href="public.html#Granular.addGrain!"><code>Granular.addGrain!</code></a></li><li><a href="public.html#Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}"><code>Granular.addGrainCylindrical!</code></a></li><li><a href="public.html#Granular.addOceanDrag!-Tuple{Granular.Simulation}"><code>Granular.addOceanDrag!</code></a></li><li><a href="public.html#Granular.applyAtmosphereDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyAtmosphereDragToGrain!</code></a></li><li><a href="public.html#Granular.applyAtmosphereVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyAtmosphereVorticityToGrain!</code></a></li><li><a href="public.html#Granular.applyOceanDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyOceanDragToGrain!</code></a></li><li><a href="public.html#Granular.applyOceanVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyOceanVorticityToGrain!</code></a></li><li><a href="public.html#Granular.areaOfQuadrilateral-NTuple{4,Array{Float64,1}}"><code>Granular.areaOfQuadrilateral</code></a></li><li><a href="public.html#Granular.areaOfTriangle-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>Granular.areaOfTriangle</code></a></li><li><a href="public.html#Granular.checkAndAddContact!"><code>Granular.checkAndAddContact!</code></a></li><li><a href="public.html#Granular.checkTimeParameters-Tuple{Granular.Simulation}"><code>Granular.checkTimeParameters</code></a></li><li><a href="public.html#Granular.compareAtmospheres-Tuple{Granular.Atmosphere,Granular.Atmosphere}"><code>Granular.compareAtmospheres</code></a></li><li><a href="public.html#Granular.compareGrains-Tuple{Granular.GrainCylindrical,Granular.GrainCylindrical}"><code>Granular.compareGrains</code></a></li><li><a href="public.html#Granular.compareOceans-Tuple{Granular.Ocean,Granular.Ocean}"><code>Granular.compareOceans</code></a></li><li><a href="public.html#Granular.compareSimulations-Tuple{Granular.Simulation,Granular.Simulation}"><code>Granular.compareSimulations</code></a></li><li><a href="public.html#Granular.conformalQuadrilateralCoordinates-NTuple{5,Array{Float64,1}}"><code>Granular.conformalQuadrilateralCoordinates</code></a></li><li><a href="public.html#Granular.convertGrainDataToArrays-Tuple{Granular.Simulation}"><code>Granular.convertGrainDataToArrays</code></a></li><li><a href="public.html#Granular.createEmptyAtmosphere-Tuple{}"><code>Granular.createEmptyAtmosphere</code></a></li><li><a href="public.html#Granular.createEmptyOcean-Tuple{}"><code>Granular.createEmptyOcean</code></a></li><li><a href="public.html#Granular.createRegularAtmosphereGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularAtmosphereGrid</code></a></li><li><a href="public.html#Granular.createRegularOceanGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularOceanGrid</code></a></li><li><a href="public.html#Granular.createSimulation-Tuple{}"><code>Granular.createSimulation</code></a></li><li><a href="public.html#Granular.disableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableAtmosphereDrag!</code></a></li><li><a href="public.html#Granular.disableGrain!-Tuple{Granular.Simulation,Int64}"><code>Granular.disableGrain!</code></a></li><li><a href="public.html#Granular.disableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableOceanDrag!</code></a></li><li><a href="public.html#Granular.disableOutputFiles!-Tuple{Granular.Simulation}"><code>Granular.disableOutputFiles!</code></a></li><li><a href="public.html#Granular.enableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableAtmosphereDrag!</code></a></li><li><a href="public.html#Granular.enableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableOceanDrag!</code></a></li><li><a href="public.html#Granular.findCellContainingPoint"><code>Granular.findCellContainingPoint</code></a></li><li><a href="public.html#Granular.findContacts!-Tuple{Granular.Simulation}"><code>Granular.findContacts!</code></a></li><li><a href="public.html#Granular.findContactsAllToAll!-Tuple{Granular.Simulation}"><code>Granular.findContactsAllToAll!</code></a></li><li><a href="public.html#Granular.findContactsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.findContactsInGrid!</code></a></li><li><a href="public.html#Granular.findEmptyPositionInGridCell-Tuple{Granular.Simulation,Any,Int64,Int64,Float64}"><code>Granular.findEmptyPositionInGridCell</code></a></li><li><a href="public.html#Granular.findLargestGrainStiffness-Tuple{Granular.Simulation}"><code>Granular.findLargestGrainStiffness</code></a></li><li><a href="public.html#Granular.findSmallestGrainMass-Tuple{Granular.Simulation}"><code>Granular.findSmallestGrainMass</code></a></li><li><a href="public.html#Granular.fitGridToGrains!-Tuple{Granular.Simulation,Any}"><code>Granular.fitGridToGrains!</code></a></li><li><a href="public.html#Granular.getCellCenterCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCenterCoordinates</code></a></li><li><a href="public.html#Granular.getCellCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCornerCoordinates</code></a></li><li><a href="public.html#Granular.getGridCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2}}"><code>Granular.getGridCornerCoordinates</code></a></li><li><a href="public.html#Granular.getNonDimensionalCellCoordinates-Tuple{Any,Int64,Int64,Array{Float64,1}}"><code>Granular.getNonDimensionalCellCoordinates</code></a></li><li><a href="public.html#Granular.grainCircumreference-Tuple{Granular.GrainCylindrical}"><code>Granular.grainCircumreference</code></a></li><li><a href="public.html#Granular.grainHorizontalSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainHorizontalSurfaceArea</code></a></li><li><a href="public.html#Granular.grainKineticRotationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticRotationalEnergy</code></a></li><li><a href="public.html#Granular.grainKineticTranslationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticTranslationalEnergy</code></a></li><li><a href="public.html#Granular.grainMass-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMass</code></a></li><li><a href="public.html#Granular.grainMomentOfInertia-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMomentOfInertia</code></a></li><li><a href="public.html#Granular.grainSideSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainSideSurfaceArea</code></a></li><li><a href="public.html#Granular.grainVolume-Tuple{Granular.GrainCylindrical}"><code>Granular.grainVolume</code></a></li><li><a href="public.html#Granular.harmonicMean-Tuple{Number,Number}"><code>Granular.harmonicMean</code></a></li><li><a href="public.html#Granular.incrementCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.incrementCurrentTime!</code></a></li><li><a href="public.html#Granular.interGrainPositionVector-Tuple{Granular.Simulation,Int64,Int64}"><code>Granular.interGrainPositionVector</code></a></li><li><a href="public.html#Granular.interact!-Tuple{Granular.Simulation}"><code>Granular.interact!</code></a></li><li><a href="public.html#Granular.interactGrains!-Tuple{Granular.Simulation,Int64,Int64,Int64}"><code>Granular.interactGrains!</code></a></li><li><a href="public.html#Granular.interpolateAtmosphereState-Tuple{Granular.Atmosphere,Float64}"><code>Granular.interpolateAtmosphereState</code></a></li><li><a href="public.html#Granular.interpolateAtmosphereVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}"><code>Granular.interpolateAtmosphereVelocitiesToCorners</code></a></li><li><a href="public.html#Granular.interpolateOceanState-Tuple{Granular.Ocean,Float64}"><code>Granular.interpolateOceanState</code></a></li><li><a href="public.html#Granular.interpolateOceanVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}"><code>Granular.interpolateOceanVelocitiesToCorners</code></a></li><li><a href="public.html#Granular.isPointInCell"><code>Granular.isPointInCell</code></a></li><li><a href="public.html#Granular.isPointInGrid"><code>Granular.isPointInGrid</code></a></li><li><a href="public.html#Granular.plotGrainSizeDistribution-Tuple{Granular.Simulation}"><code>Granular.plotGrainSizeDistribution</code></a></li><li><a href="public.html#Granular.poissonDiscSampling-Tuple{Granular.Simulation}"><code>Granular.poissonDiscSampling</code></a></li><li><a href="public.html#Granular.printGrainInfo-Tuple{Granular.GrainCylindrical}"><code>Granular.printGrainInfo</code></a></li><li><a href="public.html#Granular.printMemoryUsage-Tuple{Granular.Simulation}"><code>Granular.printMemoryUsage</code></a></li><li><a href="public.html#Granular.randpower"><code>Granular.randpower</code></a></li><li><a href="public.html#Granular.readOceanGridNetCDF-Tuple{String}"><code>Granular.readOceanGridNetCDF</code></a></li><li><a href="public.html#Granular.readOceanNetCDF-Tuple{String,String}"><code>Granular.readOceanNetCDF</code></a></li><li><a href="public.html#Granular.readOceanStateNetCDF-Tuple{String}"><code>Granular.readOceanStateNetCDF</code></a></li><li><a href="public.html#Granular.readSimulation"><code>Granular.readSimulation</code></a></li><li><a href="public.html#Granular.readSimulationStatus-Tuple{String}"><code>Granular.readSimulationStatus</code></a></li><li><a href="public.html#Granular.reflectGrainsFromImpermeableBoundaries!-Tuple{Granular.Simulation}"><code>Granular.reflectGrainsFromImpermeableBoundaries!</code></a></li><li><a href="public.html#Granular.regularPacking!-Tuple{Granular.Simulation,Array{Int64,1},Real,Real}"><code>Granular.regularPacking!</code></a></li><li><a href="public.html#Granular.removeSimulationFiles-Tuple{Granular.Simulation}"><code>Granular.removeSimulationFiles</code></a></li><li><a href="public.html#Granular.render-Tuple{Granular.Simulation}"><code>Granular.render</code></a></li><li><a href="public.html#Granular.reportGridBoundaryConditions-Tuple{Any}"><code>Granular.reportGridBoundaryConditions</code></a></li><li><a href="public.html#Granular.reportSimulationTimeToStdout-Tuple{Granular.Simulation}"><code>Granular.reportSimulationTimeToStdout</code></a></li><li><a href="public.html#Granular.resetTime!-Tuple{Granular.Simulation}"><code>Granular.resetTime!</code></a></li><li><a href="public.html#Granular.run!-Tuple{Granular.Simulation}"><code>Granular.run!</code></a></li><li><a href="public.html#Granular.setBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.setBodyForce!</code></a></li><li><a href="public.html#Granular.setCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setCurrentTime!</code></a></li><li><a href="public.html#Granular.setGridBoundaryConditions!"><code>Granular.setGridBoundaryConditions!</code></a></li><li><a href="public.html#Granular.setOutputFileInterval!-Tuple{Granular.Simulation,Float64}"><code>Granular.setOutputFileInterval!</code></a></li><li><a href="public.html#Granular.setTimeStep!-Tuple{Granular.Simulation}"><code>Granular.setTimeStep!</code></a></li><li><a href="public.html#Granular.setTotalTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setTotalTime!</code></a></li><li><a href="public.html#Granular.sortGrainsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.sortGrainsInGrid!</code></a></li><li><a href="public.html#Granular.status"><code>Granular.status</code></a></li><li><a href="public.html#Granular.totalGrainKineticRotationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticRotationalEnergy</code></a></li><li><a href="public.html#Granular.totalGrainKineticTranslationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticTranslationalEnergy</code></a></li><li><a href="public.html#Granular.updateGrainKinematics!-Tuple{Granular.Simulation}"><code>Granular.updateGrainKinematics!</code></a></li><li><a href="public.html#Granular.updateGrainKinematicsThreeTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsThreeTermTaylor!</code></a></li><li><a href="public.html#Granular.updateGrainKinematicsTwoTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsTwoTermTaylor!</code></a></li><li><a href="public.html#Granular.writeGrainInteractionVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainInteractionVTK</code></a></li><li><a href="public.html#Granular.writeGrainVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainVTK</code></a></li><li><a href="public.html#Granular.writeParaviewPythonScript-Tuple{Granular.Simulation}"><code>Granular.writeParaviewPythonScript</code></a></li><li><a href="public.html#Granular.writeSimulation-Tuple{Granular.Simulation}"><code>Granular.writeSimulation</code></a></li><li><a href="public.html#Granular.writeSimulationStatus-Tuple{Granular.Simulation}"><code>Granular.writeSimulationStatus</code></a></li><li><a href="public.html#Granular.writeVTK-Tuple{Granular.Simulation}"><code>Granular.writeVTK</code></a></li><li><a href="public.html#Granular.zeroForcesAndTorques!-Tuple{Granular.Simulation}"><code>Granular.zeroForcesAndTorques!</code></a></li><li><a href="public.html#Granular.zeroKinematics!-Tuple{Granular.Simulation}"><code>Granular.zeroKinematics!</code></a></li></ul><h2><a class="nav-anchor" id="Public-Interface-1" href="#Public-Interface-1">Public Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular" href="#Granular"><code>Granular</code></a> — <span class="docstring-category">Module</span>.</div><div><p><strong>Granular.jl</strong></p><p>Offline granular dynamics simulator module.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/Granular.jl#L3-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addAtmosphereDrag!-Tuple{Granular.Simulation}" href="#Granular.addAtmosphereDrag!-Tuple{Granular.Simulation}"><code>Granular.addAtmosphereDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Add drag from linear and angular velocity difference between atmosphere and all  grains.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L141-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}" href="#Granular.addBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.addBodyForce!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setBodyForce!(grain, force)</code></pre><p>Add to the value of the external body force on a grain.</p><p><strong>Arguments</strong></p><ul><li><p><code>grain::GrainCylindrical</code>: the grain to set the body force for.</p></li><li><p><code>force::Vector{Float64}</code>: a vector of force [N]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L623-L631">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addGrain!" href="#Granular.addGrain!"><code>Granular.addGrain!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addGrain!(simulation::Simulation,
            grain::GrainCylindrical,
            verbose::Bool = False)</code></pre><p>Add an <code>grain</code> to the <code>simulation</code> object.  If <code>verbose</code> is true, a short  confirmation message will be printed to stdout.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L202-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}" href="#Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}"><code>Granular.addGrainCylindrical!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function addGrainCylindrical!(simulation, lin_pos, contact_radius,
                                thickness[, areal_radius, lin_vel, lin_acc,
                                force, ang_pos, ang_vel, ang_acc, torque,
                                density, contact_stiffness_normal,
                                contact_stiffness_tangential,
                                contact_viscosity_normal,
                                contact_viscosity_tangential,
                                contact_static_friction,
                                contact_dynamic_friction,
                                youngs_modulus, poissons_ratio,
                                tensile_strength, tensile_heal_rate,
                                compressive_strength_prefactor,
                                ocean_drag_coeff_vert,
                                ocean_drag_coeff_horiz,
                                atmosphere_drag_coeff_vert,
                                atmosphere_drag_coeff_horiz,
                                pressure, fixed,
                                allow_x_acc, allow_y_acc,
                                rotating, enabled, verbose,
                                ocean_grid_pos, atmosphere_grid_pos,
                                n_contact, granular_stress, ocean_stress,
                                atmosphere_stress])</code></pre><p>Creates and adds a cylindrical grain to a simulation. Most of the arguments  are optional, and come with default values.  The only required arguments are  <code>simulation</code>, <code>lin_pos</code>, <code>contact_radius</code>, and <code>thickness</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation object where the grain should be   added to.</p></li><li><p><code>lin_pos::Vector{Float64}</code>: linear position of grain center [m].</p></li><li><p><code>contact_radius::Float64</code>: grain radius for granular interaction [m].</p></li><li><p><code>thickness::Float64</code>: grain thickness [m].</p></li><li><p><code>areal_radius = false</code>: grain radius for determining sea-ice concentration   [m].</p></li><li><p><code>lin_vel::Vector{Float64} = [0., 0.]</code>: linear velocity [m/s].</p></li><li><p><code>lin_acc::Vector{Float64} = [0., 0.]</code>: linear acceleration [m/s^2].</p></li><li><p><code>force::Vector{Float64} = [0., 0.]</code>: linear force balance [N].</p></li><li><p><code>ang_pos::Float64 = 0.</code>: angular position around its center vertical axis   [rad].</p></li><li><p><code>ang_vel::Float64 = 0.</code>: angular velocity around its center vertical axis   [rad/s].</p></li><li><p><code>ang_acc::Float64 = 0.</code>: angular acceleration around its center vertical axis   [rad/s^2].</p></li><li><p><code>torque::Float64 = 0.</code>: torque around its center vertical axis [N*m]</p></li><li><p><code>density::Float64 = 934.</code>: grain mean density [kg/m^3].</p></li><li><p><code>contact_stiffness_normal::Float64 = 1e7</code>: contact-normal stiffness [N/m];   overridden if <code>youngs_modulus</code> is set to a positive value.</p></li><li><p><code>contact_stiffness_tangential::Float64 = 0.</code>: contact-tangential stiffness   [N/m]; overridden if <code>youngs_modulus</code> is set to a positive value.</p></li><li><p><code>contact_viscosity_normal::Float64 = 0.</code>: contact-normal viscosity [N/m/s].</p></li><li><p><code>contact_viscosity_tangential::Float64 = 0.</code>: contact-tangential viscosity   [N/m/s].</p></li><li><p><code>contact_static_friction::Float64 = 0.4</code>: contact static Coulomb frictional   coefficient [-].</p></li><li><p><code>contact_dynamic_friction::Float64 = 0.4</code>: contact dynamic Coulomb frictional   coefficient [-].</p></li><li><p><code>youngs_modulus::Float64 = 2e7</code>: elastic modulus [Pa]; overrides any value   set for <code>contact_stiffness_normal</code>.</p></li><li><p><code>poissons_ratio::Float64 = 0.185</code>: Poisson&#39;s ratio, used to determine the   contact-tangential stiffness from <code>youngs_modulus</code> [-].</p></li><li><p><code>tensile_strength::Float64 = 0.</code>: contact-tensile (cohesive) bond strength   [Pa].</p></li><li><p><code>tensile_heal_rate::Float64 = 0.</code>: rate at which contact-tensile bond strength   is obtained [1/s].</p></li><li><p><code>compressive_strength_prefactor::Float64 = 1285e3</code>: maximum compressive   strength on granular contact (not currently enforced) [m*Pa].</p></li><li><p><code>ocean_drag_coeff_vert::Float64 = 0.85</code>: vertical drag coefficient for ocean   against grain sides [-].</p></li><li><p><code>ocean_drag_coeff_horiz::Float64 = 5e-4</code>: horizontal drag coefficient for   ocean against grain bottom [-].</p></li><li><p><code>atmosphere_drag_coeff_vert::Float64 = 0.4</code>: vertical drag coefficient for   atmosphere against grain sides [-].</p></li><li><p><code>atmosphere_drag_coeff_horiz::Float64 = 2.5e-4</code>: horizontal drag coefficient   for atmosphere against grain bottom [-].</p></li><li><p><code>pressure::Float64 = 0.</code>: current compressive stress on grain [Pa].</p></li><li><p><code>fixed::Bool = false</code>: grain is fixed to a constant velocity (e.g. zero).</p></li><li><p><code>allow_x_acc::Bool = false</code>: override <code>fixed</code> along <code>x</code>.</p></li><li><p><code>allow_y_acc::Bool = false</code>: override <code>fixed</code> along <code>y</code>.</p></li><li><p><code>rotating::Bool = true</code>: grain is allowed to rotate.</p></li><li><p><code>enabled::Bool = true</code>: grain interacts with other grains.</p></li><li><p><code>verbose::Bool = true</code>: display diagnostic information during the function   call.</p></li><li><p><code>ocean_grid_pos::Array{Int, 1} = [0, 0]</code>: position of grain in the ocean   grid.</p></li><li><p><code>atmosphere_grid_pos::Array{Int, 1} = [0, 0]</code>: position of grain in the   atmosphere grid.</p></li><li><p><code>n_contacts::Int = 0</code>: number of contacts with other grains.</p></li><li><p><code>granular_stress::Vector{Float64} = [0., 0.]</code>: resultant stress on grain   from granular interactions [Pa].</p></li><li><p><code>ocean_stress::Vector{Float64} = [0., 0.]</code>: resultant stress on grain from   ocean drag [Pa].</p></li><li><p><code>atmosphere_stress::Vector{Float64} = [0., 0.]</code>: resultant stress on grain   from atmosphere drag [Pa].</p></li></ul><p><strong>Examples</strong></p><p>The most basic example adds a new grain to the simulation <code>sim</code>, with a  center at <code>[1., 2.]</code>, a radius of <code>1.</code> meter, and a thickness of <code>0.5</code>  meter:</p><pre><code class="language-julia">Granular.addGrainCylindrical!(sim, [1., 2.], 1., .5)</code></pre><p>The following example will create a grain with tensile strength (cohesion), and a velocity of 0.5 m/s towards -x:</p><pre><code class="language-julia">Granular.addGrainCylindrical!(sim, [4., 2.], 1., .5,
                              tensile_strength = 200e3,
                              lin_vel = [-.5, 0.])</code></pre><p>Fixed grains are useful for creating walls or coasts, and loops are useful for creating regular arrangements:</p><pre><code class="language-julia">for i=1:5
    Granular.addGrainCylindrical!(sim, [i*2., 0., 3.], 1., .5, fixed=true)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L11-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addOceanDrag!-Tuple{Granular.Simulation}" href="#Granular.addOceanDrag!-Tuple{Granular.Simulation}"><code>Granular.addOceanDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Add drag from linear and angular velocity difference between ocean and all ice  floes.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L253-L256">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyAtmosphereDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}" href="#Granular.applyAtmosphereDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyAtmosphereDragToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Add Stokes-type drag from velocity difference between atmosphere and a single  grain.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L188-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyAtmosphereVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}" href="#Granular.applyAtmosphereVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyAtmosphereVorticityToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Add Stokes-type torque from angular velocity difference between atmosphere and a  single grain.  See Eq. 9.28 in &quot;Introduction to Fluid Mechanics&quot; by Nakayama  and Boucher, 1999.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L209-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyOceanDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}" href="#Granular.applyOceanDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyOceanDragToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Add Stokes-type drag from velocity difference between ocean and a single ice  floe.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L299-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyOceanVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}" href="#Granular.applyOceanVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyOceanVorticityToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Add Stokes-type torque from angular velocity difference between ocean and a  single grain.  See Eq. 9.28 in &quot;Introduction to Fluid Mechanics&quot; by Nakayama  and Boucher, 1999.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L321-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.areaOfQuadrilateral-NTuple{4,Array{Float64,1}}" href="#Granular.areaOfQuadrilateral-NTuple{4,Array{Float64,1}}"><code>Granular.areaOfQuadrilateral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the area of a quadrilateral with corner coordinates <code>a</code>, <code>b</code>, <code>c</code>, and  <code>d</code>.  Corners <code>a</code> and <code>c</code> should be opposite of each other, the same must be  true for <code>b</code> and <code>d</code>.  This is true if the four corners are passed as arguments  in a &quot;clockwise&quot; or &quot;counter-clockwise&quot; manner.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L434-L439">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.areaOfTriangle-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#Granular.areaOfTriangle-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>Granular.areaOfTriangle</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the area of an triangle with corner coordinates <code>a</code>, <code>b</code>, and <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.checkAndAddContact!" href="#Granular.checkAndAddContact!"><code>Granular.checkAndAddContact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">checkAndAddContact!(simulation, i, j)</code></pre><p>Check for contact between two grains and register the interaction in the  <code>simulation</code> object.  The indexes of the two grains is stored in  <code>simulation.contact_pairs</code> as <code>[i, j]</code>.  The overlap vector is parallel to a  straight line connecting the grain centers, points away from grain <code>i</code> and  towards <code>j</code>, and is stored in <code>simulation.overlaps</code>.  A zero-length vector is  written to <code>simulation.contact_parallel_displacement</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation object containing the grains.</p></li><li><p><code>i::Int</code>: index of the first grain.</p></li><li><p><code>j::Int</code>: index of the second grain.</p></li><li><p><code>distance_Modifier::Vector{Float64}</code>: vector modifying percieved   inter-particle distance, which is used for contact search across periodic   boundaries.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/contact_search.jl#L174-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.checkTimeParameters-Tuple{Granular.Simulation}" href="#Granular.checkTimeParameters-Tuple{Granular.Simulation}"><code>Granular.checkTimeParameters</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Checks if simulation temporal parameters are of reasonable values.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareAtmospheres-Tuple{Granular.Atmosphere,Granular.Atmosphere}" href="#Granular.compareAtmospheres-Tuple{Granular.Atmosphere,Granular.Atmosphere}"><code>Granular.compareAtmospheres</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compareAtmospheres(atmosphere1::atmosphere, atmosphere2::atmosphere)</code></pre><p>Compare values of two <code>atmosphere</code> objects using the <code>Base.Test</code> framework.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L228-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareGrains-Tuple{Granular.GrainCylindrical,Granular.GrainCylindrical}" href="#Granular.compareGrains-Tuple{Granular.GrainCylindrical,Granular.GrainCylindrical}"><code>Granular.compareGrains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compareGrains(if1::GrainCylindrical, if2::GrainCylindrical)</code></pre><p>Compare values of two grain objects using the <code>Base.Test</code> framework.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L651-L655">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareOceans-Tuple{Granular.Ocean,Granular.Ocean}" href="#Granular.compareOceans-Tuple{Granular.Ocean,Granular.Ocean}"><code>Granular.compareOceans</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compareOceans(ocean1::Ocean, ocean2::Ocean)</code></pre><p>Compare values of two <code>Ocean</code> objects using the <code>Base.Test</code> framework.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L341-L345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareSimulations-Tuple{Granular.Simulation,Granular.Simulation}" href="#Granular.compareSimulations-Tuple{Granular.Simulation,Granular.Simulation}"><code>Granular.compareSimulations</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compareSimulations(sim1::Simulation, sim2::Simulation)</code></pre><p>Compare values of two <code>Simulation</code> objects using the <code>Base.Test</code> framework.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L251-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.conformalQuadrilateralCoordinates-NTuple{5,Array{Float64,1}}" href="#Granular.conformalQuadrilateralCoordinates-NTuple{5,Array{Float64,1}}"><code>Granular.conformalQuadrilateralCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the non-dimensional coordinates <code>[x_tilde, y_tilde]</code> of a point <code>p</code>  within a quadrilateral with corner coordinates <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>. Points must be ordered in counter-clockwise order, starting from south-west  corner.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L448-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.convertGrainDataToArrays-Tuple{Granular.Simulation}" href="#Granular.convertGrainDataToArrays-Tuple{Granular.Simulation}"><code>Granular.convertGrainDataToArrays</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Gathers all grain parameters from the <code>GrainCylindrical</code> type in continuous  arrays in an <code>GrainArrays</code> structure.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L326-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createEmptyAtmosphere-Tuple{}" href="#Granular.createEmptyAtmosphere-Tuple{}"><code>Granular.createEmptyAtmosphere</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns empty ocean type for initialization purposes.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createEmptyOcean-Tuple{}" href="#Granular.createEmptyOcean-Tuple{}"><code>Granular.createEmptyOcean</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns empty ocean type for initialization purposes.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createRegularAtmosphereGrid-Tuple{Array{Int64,1},Array{Float64,1}}" href="#Granular.createRegularAtmosphereGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularAtmosphereGrid</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Initialize and return a regular, Cartesian <code>Atmosphere</code> grid with <code>n[1]</code> by <code>n[2]</code>  cells in the horizontal dimension, and <code>n[3]</code> vertical cells.  The cell corner  and center coordinates will be set according to the grid spatial dimensions  <code>L[1]</code>, <code>L[2]</code>, and <code>L[3]</code>.  The grid <code>u</code>, <code>v</code>, <code>h</code>, and <code>e</code> fields will contain  one 4-th dimension matrix per <code>time</code> step.  Sea surface will be at <code>z=0.</code> with  the atmosphere spanning <code>z&lt;0.</code>.  Vertical indexing starts with <code>k=0</code> at the sea  surface, and increases downwards.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L100-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createRegularOceanGrid-Tuple{Array{Int64,1},Array{Float64,1}}" href="#Granular.createRegularOceanGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularOceanGrid</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Initialize and return a regular, Cartesian <code>Ocean</code> grid with <code>n[1]</code> by <code>n[2]</code>  cells in the horizontal dimension, and <code>n[3]</code> vertical cells.  The cell corner  and center coordinates will be set according to the grid spatial dimensions  <code>L[1]</code>, <code>L[2]</code>, and <code>L[3]</code>.  The grid <code>u</code>, <code>v</code>, <code>h</code>, and <code>e</code> fields will contain  one 4-th dimension matrix per <code>time</code> step.  Sea surface will be at <code>z=0.</code> with  the ocean spanning <code>z&lt;0.</code>.  Vertical indexing starts with <code>k=0</code> at the sea  surface, and increases downwards.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L210-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createSimulation-Tuple{}" href="#Granular.createSimulation-Tuple{}"><code>Granular.createSimulation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">createSimulation([id::String=&quot;unnamed&quot;,
                  time_iteration::Int=0,
                  time::Float64=0.0,
                  time_total::Float64=-1.,
                  time_step::Float64=-1.,
                  file_time_step::Float64=-1.,
                  file_number::Int=0,
                  grains=Array{GrainCylindrical, 1}[],
                  ocean::Ocean,
                  atmosphere::Atmosphere)</code></pre><p>Create a simulation object containing all relevant variables such as temporal  parameters, and lists of grains and contacts. The parameter <code>id</code> is used to uniquely identify the simulation when it is written to disk.</p><p><strong>Arguments</strong></p><ul><li><p><code>id::String=&quot;unnamed&quot;</code>:</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L4-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.disableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableAtmosphereDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">disableAtmosphereDrag!(grain)</code></pre><p>Disable atmosphere-caused drag on the grain.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L821-L825">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableGrain!-Tuple{Granular.Simulation,Int64}" href="#Granular.disableGrain!-Tuple{Granular.Simulation,Int64}"><code>Granular.disableGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Disable grain with index <code>i</code> in the <code>simulation</code> object.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableOceanDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.disableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableOceanDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">disableOceanDrag!(grain)</code></pre><p>Disable ocean-caused drag on the grain.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L810-L814">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableOutputFiles!-Tuple{Granular.Simulation}" href="#Granular.disableOutputFiles!-Tuple{Granular.Simulation}"><code>Granular.disableOutputFiles!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Disables the write of output files to disk during a simulation.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.enableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.enableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableAtmosphereDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">enableAtmosphereDrag!(grain)</code></pre><p>Enable atmosphere-caused drag on the grain, with values by Hunke and Comeau (2011).</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L799-L804">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.enableOceanDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.enableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableOceanDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">enableOceanDrag!(grain)</code></pre><p>Enable ocean-caused drag on the grain, with values by Hunke and Comeau (2011).</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L788-L792">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findCellContainingPoint" href="#Granular.findCellContainingPoint"><code>Granular.findCellContainingPoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">findCellContainingPoint(grid, point[, method])</code></pre><p>Returns the <code>i</code>, <code>j</code> index of the grid cell containing the <code>point</code>. The function uses either an area-based approach (<code>method = &quot;Area&quot;</code>), or a  conformal mapping approach (<code>method = &quot;Conformal&quot;</code>).  The area-based approach is  more robust.  This function returns the coordinates of the cell.  If no match is  found the function returns <code>(0,0)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>grid::Any</code>: grid object containing ocean or atmosphere data.</p></li><li><p><code>point::Vector{Float64}</code>: two-dimensional vector of point to check.</p></li><li><p><code>method::String</code>: approach to use for determining if point is inside cell or    not, can be &quot;Conformal&quot; (default) or &quot;Areal&quot;.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L224-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findContacts!-Tuple{Granular.Simulation}" href="#Granular.findContacts!-Tuple{Granular.Simulation}"><code>Granular.findContacts!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findContacts!(simulation[, method])</code></pre><p>Top-level function to perform an inter-grain contact search, based on grain  linear positions and contact radii.</p><p>The simplest contact search algorithm (<code>method=&quot;all to all&quot;</code>) is the most  computationally expensive (O(n^2)).  The method &quot;ocean grid&quot; bins the grains  into their corresponding cells on the ocean grid and searches for contacts only  within the vicinity.  When this method is applied, it is assumed that the  <code>contact_radius</code> values of the grains are <em>smaller than half the cell size</em>.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation object containing the grains.</p></li><li><p><code>method::String</code>: the contact-search method to apply.  Valid options are &quot;all    to all&quot; and &quot;ocean grid&quot;.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/contact_search.jl#L3-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findContactsAllToAll!-Tuple{Granular.Simulation}" href="#Granular.findContactsAllToAll!-Tuple{Granular.Simulation}"><code>Granular.findContactsAllToAll!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findContactsAllToAll!(simulation)</code></pre><p>Perform an O(n^2) all-to-all contact search between all grains in the  <code>simulation</code> object.  Contacts between fixed grains are ignored.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/contact_search.jl#L67-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findContactsInGrid!-Tuple{Granular.Simulation,Any}" href="#Granular.findContactsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.findContactsInGrid!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findContactsInGrid!(simulation)</code></pre><p>Perform an O(n*log(n)) cell-based contact search between all grains in the  <code>simulation</code> object.  Contacts between fixed or disabled grains are ignored.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/contact_search.jl#L101-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findEmptyPositionInGridCell-Tuple{Granular.Simulation,Any,Int64,Int64,Float64}" href="#Granular.findEmptyPositionInGridCell-Tuple{Granular.Simulation,Any,Int64,Int64,Float64}"><code>Granular.findEmptyPositionInGridCell</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Attempt locate an empty spot for an grain with radius <code>r</code> with center  coordinates in a specified grid cell (<code>i</code>, <code>j</code>) without overlapping any other  grains in that cell or the neighboring cells.  This function will stop  attempting after <code>n_iter</code> iterations, each with randomly generated positions.</p><p>This function assumes that existing grains have been binned according to the  grid (e.g., using <code>sortGrainsInGrid()</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L514-L522">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findLargestGrainStiffness-Tuple{Granular.Simulation}" href="#Granular.findLargestGrainStiffness-Tuple{Granular.Simulation}"><code>Granular.findLargestGrainStiffness</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Finds the largest elastic stiffness of all grains in a simulation.  Used to  determine the optimal time step length.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L102-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findSmallestGrainMass-Tuple{Granular.Simulation}" href="#Granular.findSmallestGrainMass-Tuple{Granular.Simulation}"><code>Granular.findSmallestGrainMass</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Finds the smallest mass of all grains in a simulation.  Used to determine  the optimal time step length.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L86-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.fitGridToGrains!-Tuple{Granular.Simulation,Any}" href="#Granular.fitGridToGrains!-Tuple{Granular.Simulation,Any}"><code>Granular.fitGridToGrains!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fitGridToGrains!(simulation, grid[, padding])</code></pre><p>Fit the ocean or atmosphere grid for a simulation to the current grains and their positions.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: simulation object to manipulate.</p></li><li><p><code>grid::Any</code>: Ocean or Atmosphere grid to manipulate.</p></li><li><p><code>padding::Real</code>: optional padding around edges [m].</p></li><li><p><code>verbose::Bool</code>: show grid information when function completes.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L864-L875">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getCellCenterCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}" href="#Granular.getCellCenterCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCenterCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getCellCenterCoordinates(grid, i, j)</code></pre><p>Returns grid center coordinates (h-point).</p><p><strong>Arguments</strong></p><ul><li><p><code>xh::Array{Float64, 2}</code>: nominal longitude of h-points [degrees_E]</p></li><li><p><code>yh::Array{Float64, 2}</code>: nominal latitude of h-points [degrees_N]</p></li><li><p><code>i::Int</code>: x-index of cell.</p></li><li><p><code>j::Int</code>: y-index of cell.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L405-L415">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getCellCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}" href="#Granular.getCellCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCornerCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getCellCornerCoordinates(xq, yq, i, j)</code></pre><p>Returns grid-cell corner coordinates in the following order (south-west corner,  south-east corner, north-east corner, north-west corner).</p><p><strong>Arguments</strong></p><ul><li><p><code>xq::Array{Float64, 2}</code>: nominal longitude of q-points [degrees_E]</p></li><li><p><code>yq::Array{Float64, 2}</code>: nominal latitude of q-points [degrees_N]</p></li><li><p><code>i::Int</code>: x-index of cell.</p></li><li><p><code>j::Int</code>: y-index of cell.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L383-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getGridCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2}}" href="#Granular.getGridCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2}}"><code>Granular.getGridCornerCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getGridCornerCoordinates(xq, yq)</code></pre><p>Returns grid corner coordinates in the following order (south-west corner,  south-east corner, north-east corner, north-west corner).</p><p><strong>Arguments</strong></p><ul><li><p><code>xq::Array{Float64, 2}</code>: nominal longitude of q-points [degrees_E]</p></li><li><p><code>yq::Array{Float64, 2}</code>: nominal latitude of q-points [degrees_N]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L362-L371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getNonDimensionalCellCoordinates-Tuple{Any,Int64,Int64,Array{Float64,1}}" href="#Granular.getNonDimensionalCellCoordinates-Tuple{Any,Int64,Int64,Array{Float64,1}}"><code>Granular.getNonDimensionalCellCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the non-dimensional conformal mapped coordinates for point <code>point</code> in  cell <code>i,j</code>, based off the coordinates in the grid.</p><p>This function is a wrapper for <code>getCellCornerCoordinates()</code> and  <code>conformalQuadrilateralCoordinates()</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L258-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainCircumreference-Tuple{Granular.GrainCylindrical}" href="#Granular.grainCircumreference-Tuple{Granular.GrainCylindrical}"><code>Granular.grainCircumreference</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the circumreference of the grain</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainHorizontalSurfaceArea-Tuple{Granular.GrainCylindrical}" href="#Granular.grainHorizontalSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainHorizontalSurfaceArea</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the top or bottom (horizontal) surface area of the grain</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainKineticRotationalEnergy-Tuple{Granular.GrainCylindrical}" href="#Granular.grainKineticRotationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticRotationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the rotational kinetic energy of the grain</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L603">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainKineticTranslationalEnergy-Tuple{Granular.GrainCylindrical}" href="#Granular.grainKineticTranslationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticTranslationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the translational kinetic energy of the grain</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L582">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainMass-Tuple{Granular.GrainCylindrical}" href="#Granular.grainMass-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMass</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the mass of the grain</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainMomentOfInertia-Tuple{Granular.GrainCylindrical}" href="#Granular.grainMomentOfInertia-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMomentOfInertia</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the moment of inertia of the grain</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainSideSurfaceArea-Tuple{Granular.GrainCylindrical}" href="#Granular.grainSideSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainSideSurfaceArea</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the surface area of the grain sides</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainVolume-Tuple{Granular.GrainCylindrical}" href="#Granular.grainVolume-Tuple{Granular.GrainCylindrical}"><code>Granular.grainVolume</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the volume of the grain</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.harmonicMean-Tuple{Number,Number}" href="#Granular.harmonicMean-Tuple{Number,Number}"><code>Granular.harmonicMean</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">harmonicMean(a, b)</code></pre><p>Returns the harmonic mean of two numbers <code>a::Number</code> and <code>b::Number</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/util.jl#L33-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.incrementCurrentTime!-Tuple{Granular.Simulation,Float64}" href="#Granular.incrementCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.incrementCurrentTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">incrementCurrentTime!(simulation::Simulation, t::Float64)</code></pre><p>Sets the current simulation time of the <code>simulation</code> object to <code>t</code>, with  parameter value checks.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L32-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interGrainPositionVector-Tuple{Granular.Simulation,Int64,Int64}" href="#Granular.interGrainPositionVector-Tuple{Granular.Simulation,Int64,Int64}"><code>Granular.interGrainPositionVector</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">interGrainPositionVector(simulation, i, j)</code></pre><p>Returns a <code>vector</code> pointing from grain <code>i</code> to grain <code>j</code> in the  <code>simulation</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation object containing the grains.</p></li><li><p><code>i::Int</code>: index of the first grain.</p></li><li><p><code>j::Int</code>: index of the second grain.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/contact_search.jl#L39-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interact!-Tuple{Granular.Simulation}" href="#Granular.interact!-Tuple{Granular.Simulation}"><code>Granular.interact!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">interact!(simulation::Simulation)</code></pre><p>Resolve mechanical interaction between all particle pairs.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/interaction.jl#L4-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interactGrains!-Tuple{Granular.Simulation,Int64,Int64,Int64}" href="#Granular.interactGrains!-Tuple{Granular.Simulation,Int64,Int64,Int64}"><code>Granular.interactGrains!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">interactGrains!(simulation::Simulation, i::Int, j::Int, ic::Int)</code></pre><p>Resolve an grain-to-grain interaction using a prescibed contact law.  This  function adds the compressive force of the interaction to the grain  <code>pressure</code> field of mean compressive stress on the grain sides.</p><p>The function uses the macroscopic contact-stiffness parameterization based on  Young&#39;s modulus and Poisson&#39;s ratio if Young&#39;s modulus is a positive value.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/interaction.jl#L32-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interpolateAtmosphereState-Tuple{Granular.Atmosphere,Float64}" href="#Granular.interpolateAtmosphereState-Tuple{Granular.Atmosphere,Float64}"><code>Granular.interpolateAtmosphereState</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Atmosphere data is containted in <code>Atmosphere</code> type at discrete times  (<code>Atmosphere.time</code>).  This function performs linear interpolation between time  steps to get the approximate atmosphere state at any point in time.  If the  <code>Atmosphere</code> data set only contains a single time step, values from that time  are returned.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L62-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interpolateAtmosphereVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}" href="#Granular.interpolateAtmosphereVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}"><code>Granular.interpolateAtmosphereVelocitiesToCorners</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Convert gridded data from Arakawa-C type (decomposed velocities at faces) to  Arakawa-B type (velocities at corners) through interpolation.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/atmosphere.jl#L28-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interpolateOceanState-Tuple{Granular.Ocean,Float64}" href="#Granular.interpolateOceanState-Tuple{Granular.Ocean,Float64}"><code>Granular.interpolateOceanState</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Ocean data is containted in <code>Ocean</code> type at discrete times (<code>Ocean.time</code>).  This  function performs linear interpolation between time steps to get the approximate  ocean state at any point in time.  If the <code>Ocean</code> data set only contains a  single time step, values from that time are returned.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L173-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interpolateOceanVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}" href="#Granular.interpolateOceanVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}"><code>Granular.interpolateOceanVelocitiesToCorners</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Convert gridded data from Arakawa-C type (decomposed velocities at faces) to  Arakawa-B type (velocities at corners) through interpolation.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L141-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.isPointInCell" href="#Granular.isPointInCell"><code>Granular.isPointInCell</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Check if a 2d point is contained inside a cell from the supplied grid. The function uses either an area-based approach (<code>method = &quot;Area&quot;</code>), or a  conformal mapping approach (<code>method = &quot;Conformal&quot;</code>).  The area-based approach is  more robust.  This function returns <code>true</code> or <code>false</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L273-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.isPointInGrid" href="#Granular.isPointInGrid"><code>Granular.isPointInGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Check if a 2d point is contained inside the grid.  The function uses either an area-based approach (<code>method = &quot;Area&quot;</code>), or a conformal mapping approach (<code>method = &quot;Conformal&quot;</code>).  The area-based approach is more robust.  This function returns <code>true</code> or <code>false</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L317-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.plotGrainSizeDistribution-Tuple{Granular.Simulation}" href="#Granular.plotGrainSizeDistribution-Tuple{Granular.Simulation}"><code>Granular.plotGrainSizeDistribution</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">plotGrainSizeDistribution(simulation, [filename_postfix], [nbins],
                            [size_type], [figsize], [filetype])</code></pre><p>Plot the grain size distribution as a histogram and save it to the disk.  The  plot is saved accoring to the simulation id, the optional <code>filename_postfix</code>  string, and the <code>filetype</code>, and is written to the current folder.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation object containing the grains.</p></li><li><p><code>filename_postfix::String</code>: optional string for the output filename.</p></li><li><p><code>nbins::Int</code>: number of bins in the histogram (default = 12).</p></li><li><p><code>size_type::String</code>: specify whether to use the <code>contact</code> or <code>areal</code> radius    for the grain size.  The default is <code>contact</code>.</p></li><li><p><code>figsize::Tuple</code>: the output figure size in inches (default = (6,4).</p></li><li><p><code>filetype::String</code>: the output file type (default = &quot;png&quot;).</p></li><li><p><code>verbose::String</code>: show output file as info message in stdout (default =    true).</p></li><li><p><code>skip_fixed::Bool</code>: ommit grains that are fixed in space from the size    distribution (default = true).</p></li><li><p><code>logy::Bool</code>: plot y-axis in log scale.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L725-L746">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.poissonDiscSampling-Tuple{Granular.Simulation}" href="#Granular.poissonDiscSampling-Tuple{Granular.Simulation}"><code>Granular.poissonDiscSampling</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Generate disc packing in 2D using Poisson disc sampling with O(N) complexity, as described by <a href="http://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf">Robert Bridson (2007)</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: simulation object where grains are inserted.</p></li><li><p><code>radius_max::Real</code>: largest grain radius to use.</p></li><li><p><code>radius_min::Real</code>: smallest grain radius to use.</p></li><li><p><code>sample_limit::Integer=30</code>: number of points to sample around each grain   before giving up.</p></li><li><p><code>max_padding_factor::Real=2.</code>: this factor scales the padding to use during ice   floe generation in numbers of grain diameters.</p></li><li><p><code>verbose::Bool=true</code>: show diagnostic information to stdout.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/packing.jl#L78-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.printGrainInfo-Tuple{Granular.GrainCylindrical}" href="#Granular.printGrainInfo-Tuple{Granular.GrainCylindrical}"><code>Granular.printGrainInfo</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">printGrainInfo(grain::GrainCylindrical)</code></pre><p>Prints the contents of an grain to stdout in a formatted style.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L519-L523">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.printMemoryUsage-Tuple{Granular.Simulation}" href="#Granular.printMemoryUsage-Tuple{Granular.Simulation}"><code>Granular.printMemoryUsage</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">printMemoryUsage(sim::Simulation)</code></pre><p>Shows the memory footprint of the simulation object.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L279-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.randpower" href="#Granular.randpower"><code>Granular.randpower</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randpower([nvals], [distribution_power], [min_val], [max_val])</code></pre><p>Returns one or more random numbers from a power-law probability distribution.</p><p><strong>Arguments</strong></p><ul><li><p><code>dims::Any</code>: the dimensions of random values (default = 1)</p></li><li><p><code>distribution_power::Number</code>: the distribution power (default = 1.)</p></li><li><p><code>min_val::Number</code>: the lower bound of the distribution range (default = 0.)</p></li><li><p><code>max_val::Number</code>: the upper bound of the distribution range (default = 1.)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/util.jl#L4-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readOceanGridNetCDF-Tuple{String}" href="#Granular.readOceanGridNetCDF-Tuple{String}"><code>Granular.readOceanGridNetCDF</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Read NetCDF file with ocean <em>supergrid</em> information generated by MOM6 (e.g.   <code>ocean_hrid.nc</code>) from disk and return as <code>Ocean</code> data structure.  This file is  located in the simulation <code>INPUT/</code> subdirectory.</p><p><strong>Returns</strong></p><ul><li><p><code>xh::Array{Float64, 2}</code>: Longitude for cell centers [deg]</p></li><li><p><code>yh::Array{Float64, 2}</code>: Latitude for cell centers [deg]</p></li><li><p><code>xq::Array{Float64, 2}</code>: Longitude for cell corners [deg]</p></li><li><p><code>yq::Array{Float64, 2}</code>: Latitude for cell corners [deg]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L112-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readOceanNetCDF-Tuple{String,String}" href="#Granular.readOceanNetCDF-Tuple{String,String}"><code>Granular.readOceanNetCDF</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Read ocean NetCDF files generated by MOM6 from disk and return as <code>Ocean</code> data  structure.</p><p><strong>Arguments</strong></p><ul><li><p><code>velocity_file::String</code>: Path to NetCDF file containing ocean velocities,    etc., (e.g. <code>prog__####_###.nc</code>).</p></li><li><p><code>grid_file::String</code>: Path to NetCDF file containing ocean super-grid    information (typically <code>INPUT/ocean_hgrid.nc</code>).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L27-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readOceanStateNetCDF-Tuple{String}" href="#Granular.readOceanStateNetCDF-Tuple{String}"><code>Granular.readOceanStateNetCDF</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Read NetCDF file with ocean state generated by MOM6 (e.g.  <code>prog__####_###.nc</code>  or <code>########.ocean_month.nc</code>) from disk and return time stamps, velocity fields,  layer thicknesses, interface heights, and vertical coordinates.</p><p><strong>Returns</strong></p><ul><li><p><code>time::Vector{Float64}</code>: Time [s]</p></li><li><p><code>u::Array{Float64, 2}</code>: Cell corner zonal velocity [m/s],   dimensions correspond to placement in <code>[xq, yq, zl, time]</code></p></li><li><p><code>v::Array{Float64, 2}</code>: Cell corner meridional velocity [m/s],   dimensions correspond to placement in <code>[xq, yq, zl, time]</code></p></li><li><p><code>h::Array{Float64, 2}</code>: layer thickness [m], dimensions correspond to    placement in <code>[xh, yh, zl, time]</code></p></li><li><p><code>e::Array{Float64, 2}</code>: interface height relative to mean sea level [m],     dimensions correspond to placement in <code>[xh, yh, zi, time]</code></p></li><li><p><code>zl::Vector{Float64}</code>: layer target potential density [kg m^-3]</p></li><li><p><code>zi::Vector{Float64}</code>: interface target potential density [kg m^-3]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/ocean.jl#L72-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readSimulation" href="#Granular.readSimulation"><code>Granular.readSimulation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readSimulation(filename::String=&quot;&quot;;
               verbose::Bool=true)</code></pre><p>Read all content from <code>Simulation</code> from disk in JDL format.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L49-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readSimulationStatus-Tuple{String}" href="#Granular.readSimulationStatus-Tuple{String}"><code>Granular.readSimulationStatus</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">readSimulationStatus(filename::String;
                     folder::String=&quot;.&quot;,
                     verbose::Bool=false)</code></pre><p>Write current simulation status to disk in a minimal txt file.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L95-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.reflectGrainsFromImpermeableBoundaries!-Tuple{Granular.Simulation}" href="#Granular.reflectGrainsFromImpermeableBoundaries!-Tuple{Granular.Simulation}"><code>Granular.reflectGrainsFromImpermeableBoundaries!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reflectGrainsFromImpermeableBoundaries!(simulation::Simulation)</code></pre><p>If the ocean or atmosphere grids are impermeable, reflect grain trajectories by reversing the velocity vectors normal to the boundary.  This function is to be called after temporal integration of the grain positions.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L796-L802">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.regularPacking!-Tuple{Granular.Simulation,Array{Int64,1},Real,Real}" href="#Granular.regularPacking!-Tuple{Granular.Simulation,Array{Int64,1},Real,Real}"><code>Granular.regularPacking!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">regularPacking!(simulation, n, r_min, r_max[, padding_factor,
                size_distribution, size_distribution_parameter])</code></pre><p>Create a grid-based regular packing with grain numbers along each axis specified by the <code>n</code> vector.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: simulation object where the grains are inserted,   preferably not containing prior grains.</p></li><li><p><code>n::Vector{Integer}</code>: 2-element vector determining number of grains along the   <code>x</code> and <code>y</code> axes.</p></li><li><p><code>r_min::Real</code>: minimum desired grain radius.</p></li><li><p><code>r_max::Real</code>: maximum desired grain radius.</p></li><li><p><code>padding_factor::Real</code>: percentage-wise padding around each grain to allow for   random perturbations to grain position.</p></li><li><p><code>size_distribution::String</code>: grain-size distribution to sample. Valid values   are &quot;powerlaw&quot; and &quot;uniform&quot;.</p></li><li><p><code>size_distribution_parameter::Real</code>: parameter to pass to the grain-size   distribution generating function.</p></li><li><p><code>seed::Integer</code>: seed value to the pseudo-random number generator.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/packing.jl#L4-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.removeSimulationFiles-Tuple{Granular.Simulation}" href="#Granular.removeSimulationFiles-Tuple{Granular.Simulation}"><code>Granular.removeSimulationFiles</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removeSimulationFiles(simulation[, folder])</code></pre><p>Remove all simulation output files from the specified folder.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L976-L980">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.render-Tuple{Granular.Simulation}" href="#Granular.render-Tuple{Granular.Simulation}"><code>Granular.render</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">render(simulation[, pvpython, images, animation])</code></pre><p>Wrapper function which calls <code>writeParaviewPythonScript(...)</code> and executes it from the shell using the supplied <code>pvpython</code> argument.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: simulation object containing the grain data.</p></li><li><p><code>pvpython::String</code>: path to the <code>pvpython</code> executable to use.  By default, the   script uses the pvpython in the system PATH.</p></li><li><p><code>images::Bool</code>: render images to disk (default: true)</p></li><li><p><code>animation::Bool</code>: render animation to disk (default: false)</p></li><li><p><code>trim::Bool</code>: trim images in animated sequence (default: true)</p></li><li><p><code>reverse::Bool</code>: if <code>images=true</code> additionally render reverse-animated gif   (default: false)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L913-L928">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.reportGridBoundaryConditions-Tuple{Any}" href="#Granular.reportGridBoundaryConditions-Tuple{Any}"><code>Granular.reportGridBoundaryConditions</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reportGridBoundaryConditions(grid)</code></pre><p>Report the boundary conditions for the grid to the console.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L719-L723">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.reportSimulationTimeToStdout-Tuple{Granular.Simulation}" href="#Granular.reportSimulationTimeToStdout-Tuple{Granular.Simulation}"><code>Granular.reportSimulationTimeToStdout</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Prints the current simulation time and total time to standard out</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.resetTime!-Tuple{Granular.Simulation}" href="#Granular.resetTime!-Tuple{Granular.Simulation}"><code>Granular.resetTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">resetTime!(simulation)</code></pre><p>Reset the current time to zero, and reset output file counters in order to restart a simulation.  This function does not overwrite the time step (<code>Simulation.time_step</code>), the output file interval (<code>Simulation.file_time_step</code>), or the total simulation time (<code>Simulation.time_total</code>).</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation object for which to reset the   temporal parameters.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L170-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.run!-Tuple{Granular.Simulation}" href="#Granular.run!-Tuple{Granular.Simulation}"><code>Granular.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(simulation[,
     verbose::Bool = true,
     status_interval = 100.,
     show_file_output = true,
     single_step = false,
     temporal_integration_method = &quot;Three-term Taylor&quot;],
     write_jld = false)</code></pre><p>Run the <code>simulation</code> through time until <code>simulation.time</code> equals or exceeds  <code>simulatim.time_total</code>.  This function requires that all grains are added to  the simulation and that the length of the computational time step is adjusted  accordingly.</p><p>The function will search for contacts, determine the force balance on each ice  floe, and integrate all kinematic degrees of freedom accordingly.  The temporal  integration is explicit and of length <code>simulation.time_step</code>.  This function  will write VTK files to disk in the intervals <code>simulation.file_time_step</code> by the  function <code>writeVTK</code>.  If this value is negative, no output files will be written  to disk.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation to run (object is modified)</p></li><li><p><code>verbose::Bool=true</code>: show verbose information during the time loop</p></li><li><p><code>status_interval::Bool=true</code>: show verbose information during the time loop</p></li><li><p><code>show_file_output::Bool=true</code>: report to stdout when output file is written</p></li><li><p><code>single_step::Bool=false</code>: run simulation for a single time step only.  If    this causes <code>simulation.time</code> to exceed <code>simulation.time_total</code>, the latter    is increased accordingly.</p></li><li><p><code>temporal_integration_method::String=&quot;Three-term Taylor&quot;</code>: type of integration    method to use.  See <code>updateGrainKinematics</code> for details.</p></li><li><p><code>write_jld::Bool=false</code>: write simulation state to disk as JLD files (see    <code>Granular.writeSimulation(...)</code> whenever saving VTK output.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L53-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}" href="#Granular.setBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.setBodyForce!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setBodyForce!(grain, force)</code></pre><p>Set the value of the external body force on a grain.</p><p><strong>Arguments</strong></p><ul><li><p><code>grain::GrainCylindrical</code>: the grain to set the body force for.</p></li><li><p><code>force::Vector{Float64}</code>: a vector of force [N]</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L637-L645">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setCurrentTime!-Tuple{Granular.Simulation,Float64}" href="#Granular.setCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setCurrentTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setCurrentTime!(simulation::Simulation, t::Float64)</code></pre><p>Sets the current simulation time of the <code>simulation</code> object to <code>t</code>, with  parameter value checks.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L17-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setGridBoundaryConditions!" href="#Granular.setGridBoundaryConditions!"><code>Granular.setGridBoundaryConditions!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setGridBoundaryConditions!(grid, grid_face, mode)</code></pre><p>Set boundary conditions for the granular phase at the edges of <code>Ocean</code> or <code>Atmosphere</code> grids.  The target boundary can be selected through the <code>grid_face</code> argument, or the same boundary condition can be applied to all grid boundaries at once.</p><p>When the center coordinate of grains crosses an inactive boundary (<code>mode = &quot;inactive&quot;</code>), the grain is disabled (<code>GrainCylindrical.enabled = false</code>).  This keeps the grain in memory, but stops it from moving or interacting with other grains.  <em>By default, all boundaries are inactive</em>.</p><p>If the center coordinate of a grain crosses a periodic boundary (<code>mode = periodic</code>), the grain is repositioned to the opposite side of the model domain. Grains can interact mechanically across the periodic boundary.</p><p><strong>Arguments</strong></p><ul><li><p><code>grid::Any</code>: <code>Ocean</code> or <code>Atmosphere</code> grid to apply the boundary condition to.</p></li><li><p><code>grid_face::String</code>: Grid face to apply the boundary condition to.  Valid   values are any combination and sequence of <code>&quot;west&quot;</code> (-x), <code>&quot;south&quot;</code> (-y),   <code>&quot;east&quot;</code> (+x), <code>&quot;north&quot;</code> (+y).  The values may be delimited in any way.   Also, and by default, all boundaries can be selected with <code>&quot;all&quot;</code> (-x, -y,   +x, +y), which overrides any other face selection.</p></li><li><p><code>mode::String</code>: Boundary behavior, accepted values are <code>&quot;inactive&quot;</code>,   <code>&quot;periodic&quot;</code>, and <code>&quot;impermeable&quot;</code>.  You cannot specify more than one mode at   a time, so if several modes are desired as boundary conditions for the grid,   several calls to this function should be made.</p></li><li><p><code>verbose::Bool</code>: Confirm boundary conditions by reporting values to console.</p></li></ul><p><strong>Examples</strong></p><p>Set all boundaries for the ocean grid to be periodic:</p><pre><code class="language-none">setGridBoundaryConditions!(ocean, &quot;periodic&quot;, &quot;all&quot;)</code></pre><p>Set the south-north boundaries to be inactive, but the west-east boundaries to be periodic:</p><pre><code class="language-none">setGridBoundaryConditions!(ocean, &quot;inactive&quot;, &quot;south north&quot;)
setGridBoundaryConditions!(ocean, &quot;periodic&quot;, &quot;west east&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L622-L663">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setOutputFileInterval!-Tuple{Granular.Simulation,Float64}" href="#Granular.setOutputFileInterval!-Tuple{Granular.Simulation,Float64}"><code>Granular.setOutputFileInterval!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>setOutputFileInterval!(simulation::Simulation, t::Float64)</p><p>Sets the simulation-time interval between output files are written to disk.  If  this value is zero or negative, no output files will be written.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L48-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setTimeStep!-Tuple{Granular.Simulation}" href="#Granular.setTimeStep!-Tuple{Granular.Simulation}"><code>Granular.setTimeStep!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setTimeStep!(simulation[, epsilon, verbose])</code></pre><p>Find the computational time step length suitable given the grain radii, contact stiffnesses, and grain density. Uses the scheme by Radjaii et al. 2011.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: the simulation object to modify.</p></li><li><p><code>epsilon::Float64=0.07</code>: safety factor in the time step scheme. Larger values   are more likely to cause unstable behavior than smaller values.</p></li><li><p><code>verbose::Bool=true</code>: display the resultant time step in the console.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L135-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setTotalTime!-Tuple{Granular.Simulation,Float64}" href="#Granular.setTotalTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setTotalTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setTotalTime!(simulation::Simulation, t::Float64)</code></pre><p>Sets the total simulation time of the <code>simulation</code> object to <code>t</code>, with parameter  value checks.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal.jl#L2-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.sortGrainsInGrid!-Tuple{Granular.Simulation,Any}" href="#Granular.sortGrainsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.sortGrainsInGrid!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Find grain positions in grid, based on their center positions.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grid.jl#L112-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.status" href="#Granular.status"><code>Granular.status</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Shows the status of all simulations with output files written under the  specified <code>folder</code>, which is the current working directory by default.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L120-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.totalGrainKineticRotationalEnergy-Tuple{Granular.Simulation}" href="#Granular.totalGrainKineticRotationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticRotationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">totalGrainKineticRotationalEnergy(simulation)</code></pre><p>Returns the sum of rotational kinetic energies of all grains in a simulation</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L609-L613">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.totalGrainKineticTranslationalEnergy-Tuple{Granular.Simulation}" href="#Granular.totalGrainKineticTranslationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticTranslationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">totalGrainKineticTranslationalEnergy(simulation)</code></pre><p>Returns the sum of translational kinetic energies of all grains in a  simulation</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L588-L593">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateGrainKinematics!-Tuple{Granular.Simulation}" href="#Granular.updateGrainKinematics!-Tuple{Granular.Simulation}"><code>Granular.updateGrainKinematics!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">updateGrainKinematics!(simulation::Simulation[,
                         method::String = &quot;Three-term Taylor&quot;])</code></pre><p>Update the grain kinematic parameters using a temporal integration scheme, the current force and torque balance, and gravitational acceleration.  If the simulation contains a grid with periodic boundaries, affected grain positions are adjusted accordingly.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: update the grain positions in this object    according to temporal integration of length <code>simulation.time_step</code>.</p></li><li><p><code>method::String = &quot;Three-term Taylor&quot;</code>: the integration method to use.     Available methods are &quot;Two-term Taylor&quot; and &quot;Three-term Taylor&quot;.  The    three-term Taylor expansion is slightly more computationally expensive than    the two-term Taylor expansion, but offers an order-of-magnitude increase in    precision of grain positions.  The two-term expansion can obtain similar    precision if the time step is 1/10 the length.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal_integration.jl#L2-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateGrainKinematicsThreeTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}" href="#Granular.updateGrainKinematicsThreeTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsThreeTermTaylor!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Use a three-term Taylor expansion for integrating the kinematic degrees of  freedom for an <code>grain</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal_integration.jl#L81-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateGrainKinematicsTwoTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}" href="#Granular.updateGrainKinematicsTwoTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsTwoTermTaylor!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Use a two-term Taylor expansion for integrating the kinematic degrees of freedom  for an <code>grain</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/temporal_integration.jl#L47-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeGrainInteractionVTK-Tuple{Granular.Simulation,String}" href="#Granular.writeGrainInteractionVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainInteractionVTK</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">writeGrainInteractionVTK(simulation::Simulation,
                           filename::String;
                           verbose::Bool=false)</code></pre><p>Saves grain interactions to <code>.vtp</code> files for visualization with VTK, for  example in Paraview.  Convert Cell Data to Point Data and use with Tube filter.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L357-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeGrainVTK-Tuple{Granular.Simulation,String}" href="#Granular.writeGrainVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainVTK</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Write a VTK file to disk containing all grains in the <code>simulation</code> in an  unstructured mesh (file type <code>.vtu</code>).  These files can be read by ParaView and  can be visualized by applying a <em>Glyph</em> filter.  This function is called by  <code>writeVTK()</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L252-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeParaviewPythonScript-Tuple{Granular.Simulation}" href="#Granular.writeParaviewPythonScript-Tuple{Granular.Simulation}"><code>Granular.writeParaviewPythonScript</code></a> — <span class="docstring-category">Method</span>.</div><div><p>function writeParaviewPythonScript(simulation,                                    [filename, folder, vtk_folder, verbose])</p><p>Create a <code>&quot;.py&quot;</code> script for visualizing the simulation VTK files in Paraview. The script can be run from the command line with <code>pvpython</code> (bundled with Paraview), or from the interactive Python shell inside Paraview.</p><p><strong>Arguments</strong></p><ul><li><p><code>simulation::Simulation</code>: input simulation file containing the data.</p></li><li><p><code>filename::String</code>: output file name for the Python script. At its default   (blank) value, the script is named after the simulation id (<code>simulation.id</code>).</p></li><li><p><code>folder::String</code>: output directory, current directory the default.</p></li><li><p><code>vtk_folder::String</code>: directory containing the VTK output files, by default   points to the full system path equivalent to <code>&quot;./&lt;simulation.id&gt;/&quot;</code>.</p></li><li><p><code>save_animation::Bool</code>: make the generated script immediately save a rendered   animation to disk when the <code>&quot;.py&quot;</code> script is called.</p></li><li><p><code>verbose::Bool</code>: show diagnostic information during</p></li></ul><p>function call, on by     default.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L652-L672">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeSimulation-Tuple{Granular.Simulation}" href="#Granular.writeSimulation-Tuple{Granular.Simulation}"><code>Granular.writeSimulation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">writeSimulation(simulation::Simulation;
                     filename::String=&quot;&quot;,
                     folder::String=&quot;.&quot;,
                     verbose::Bool=true)</code></pre><p>Write all content from <code>Simulation</code> to disk in JDL format.  If the <code>filename</code>  parameter is not specified, it will be saved to a subdirectory under the current  directory named after the simulation identifier <code>simulation.id</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L13-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeSimulationStatus-Tuple{Granular.Simulation}" href="#Granular.writeSimulationStatus-Tuple{Granular.Simulation}"><code>Granular.writeSimulationStatus</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">writeSimulationStatus(simulation::Simulation;
                      folder::String=&quot;.&quot;,
                      verbose::Bool=false)</code></pre><p>Write current simulation status to disk in a minimal txt file.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L71-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeVTK-Tuple{Granular.Simulation}" href="#Granular.writeVTK-Tuple{Granular.Simulation}"><code>Granular.writeVTK</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Write a VTK file to disk containing all grains in the <code>simulation</code> in an  unstructured mesh (file type <code>.vtu</code>).  These files can be read by ParaView and  can be visualized by applying a <em>Glyph</em> filter.</p><p>If the simulation contains an <code>Ocean</code> data structure, it&#39;s contents will be  written to separate <code>.vtu</code> files.  This can be disabled by setting the argument  <code>ocean=false</code>.  The same is true for the atmosphere.</p><p>The VTK files will be saved in a subfolder named after the simulation.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/io.jl#L208-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.zeroForcesAndTorques!-Tuple{Granular.Simulation}" href="#Granular.zeroForcesAndTorques!-Tuple{Granular.Simulation}"><code>Granular.zeroForcesAndTorques!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Sets the <code>force</code> and <code>torque</code> values of all grains to zero.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/simulation.jl#L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.zeroKinematics!-Tuple{Granular.Simulation}" href="#Granular.zeroKinematics!-Tuple{Granular.Simulation}"><code>Granular.zeroKinematics!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">zeroKinematics!(simulation)</code></pre><p>Set all grain forces, torques, accelerations, and velocities (linear and rotational) to zero in order to get rid of all kinetic energy.</p></div><a class="source-link" target="_blank" href="https://github.com/anders-dc/Granular.jl/blob/14ea449b6e90da5594261c7eda7efc135ee61982/src/grain.jl#L832-L837">source</a></section><footer><hr/><a class="previous" href="../man/getting_started.html"><span class="direction">Previous</span><span class="title">Getting started</span></a><a class="next" href="internals.html"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
